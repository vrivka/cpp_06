# C++ - modules

C++ - modules серия задач для изучения различных аспектов языка C++ и ООП.

## Ссылки на другие модули

0. [CPP module 00](https://github.com/vrivka/cpp_00)
1. [CPP module 01](https://github.com/vrivka/cpp_01)
2. [CPP module 02](https://github.com/vrivka/cpp_02)
3. [CPP module 03](https://github.com/vrivka/cpp_03)
4. [CPP module 04](https://github.com/vrivka/cpp_04)
5. [CPP module 05](https://github.com/vrivka/cpp_05)
6. CPP module 06
7. [CPP module 07](https://github.com/vrivka/cpp_07)
8. [CPP module 08](https://github.com/vrivka/cpp_08)

# C++ - Module 06

## Описание модуля

Этот модуль разработан, чтобы помочь понять различные `cast`\`ы в C++.

## Задачи

### Exercise 00: Conversion of scalar types

Нужно написать программу, которая принимает в качестве параметра строковое представление литерала C++ в его наиболее распространенной форме. Этот литерал должен принадлежать к одному из следующих скалярных типов: `char`, `int`, `float` или `double`. За исключением `char`, для отображения будет использоваться только десятичная запись.

Примеры литералов `char`: `'c'`, `'a'`, ...

Для простоты обратим внимание, что не отображаемые символы, не должны использоваться в качестве входных данных. Если преобразование в `char` непечатаемое, то выводится информационное сообщение.

Примеры литералов `int`: `0`, `-42`, `42`, ...

Примеры литералов `float`: `0.0f`, `-4.2f`, `4.2f`, ...

Также должны обрабатываться эти псевдолитералы: `-inff`, `+inff` и `nanf`.

Примеры литералов `double`: `0.0`, `-4.2`, `4.2`, ...

Также должны обрабатываться эти псевдолитералы: `-inf`, `+inf` и `nan`.

Нужно сначала определить тип литерала, переданного в качестве параметра, преобразовать его из строки в фактический тип, а затем явно преобразовать в три других типа данных. Наконец, отобразить результаты.

Если преобразование не имеет смысла или приводит к переполнению, отобразить сообщение, информирующее пользователя о том, что преобразование типа невозможно.

### Exercise 01: Serialization

Реализовать следующие функции:

```C++
uintptr_t serialize(Data* ptr);
```

Он берет указатель и преобразует его в беззнаковый целочисленный тип `uintptr_t`.

```C++
Data* deserialize(uintptr_t raw);
```

Он принимает беззнаковый целочисленный параметр и преобразует его в указатель на `Data`.

### Exercise 02: Identify real type

Требуется реализовать класс `Base`, который имеет только `public` виртуальный деструктор. Создать три пустых класса `A`, `B` и `C`, которые публично наследуются от `Base`.

Реализовать следующие функции:

```C++
Base * generate(void);
```

Она случайным образом создает экземпляры `A`, `B` или `C` и возвращает экземпляр в качестве базового указателя.

```C++
void identify(Base* p);
```

Она печатает фактический тип объекта, на который указывает `p`: `A`, `B` или `C`.

```C++
void identify(Base& p);
```

Она печатает фактический тип объекта, на который указывает `p`: `A`, `B` или `C`. Использование указателя внутри этой функции запрещено. Включение заголовка `typeinfo` запрещено.

###### Навигация по модулям
[<<<<](https://github.com/vrivka/cpp_05)
[00](https://github.com/vrivka/cpp_00) |
[01](https://github.com/vrivka/cpp_01) |
[02](https://github.com/vrivka/cpp_02) |
[03](https://github.com/vrivka/cpp_03) |
[04](https://github.com/vrivka/cpp_04) |
[05](https://github.com/vrivka/cpp_05) |
06 |
[07](https://github.com/vrivka/cpp_07) |
[08](https://github.com/vrivka/cpp_08) |
[>>>>](https://github.com/vrivka/cpp_07)